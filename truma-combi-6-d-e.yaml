esphome:
  name: truma

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

external_components:
  - source:
      type: local
      path: components
    components: ["truma_inetbox", "uart"]
  # - source:
  #     type: git
  #     url: https://github.com/simplenotezy/esphome-truma_inetbox
  #     ref: feat/arduino_3
  #   components: ["truma_inetbox"]
  #   refresh: 0s

# ---------------------------------------------------------
# NETWORK SECTION
# ---------------------------------------------------------
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Fallback hotspot if it can't reach "Network Name"
  ap:
    ssid: "Fallback Hotspot"
    password: "Sw9g4XJtoyrn"

api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

logger:
  level: DEBUG

web_server:
  port: 80
  local: true
  version: 2
  include_internal: true

# ---------------------------------------------------------
# TIME SYNC (only if drifted >30s, once per boot)
# ---------------------------------------------------------
globals:
  - id: clock_synced
    type: bool
    restore_value: no
    initial_value: 'false'

time:
  - platform: homeassistant
    id: homeassistant_time
    on_time_sync:
      then:
        - if:
            condition:
              lambda: 'return !id(clock_synced);'
            then:
              - lambda: 'id(clock_synced) = true;'  # Mark checked regardless
              - if:
                  condition:
                    lambda: |-
                      // Check if CP Plus clock data is valid
                      auto clock_status = id(truma)->get_clock()->get_status();
                      if (!id(truma)->get_clock()->get_status_valid()) {
                        ESP_LOGD("clock_sync", "CP Plus clock not yet received, syncing anyway");
                        return true;  // Sync if we haven't received clock data yet
                      }
                      
                      // Get current HA time
                      auto now = id(homeassistant_time).now();
                      if (!now.is_valid()) return false;
                      
                      // Calculate drift in seconds
                      int ha_seconds = now.hour * 3600 + now.minute * 60 + now.second;
                      int cp_seconds = clock_status->clock_hour * 3600 + clock_status->clock_minute * 60 + clock_status->clock_second;
                      int drift = abs(ha_seconds - cp_seconds);
                      
                      // Handle midnight wraparound (e.g., 23:59 vs 00:01)
                      if (drift > 43200) drift = 86400 - drift;
                      
                      ESP_LOGD("clock_sync", "CP Plus: %02d:%02d:%02d, HA: %02d:%02d:%02d, Drift: %ds",
                               clock_status->clock_hour, clock_status->clock_minute, clock_status->clock_second,
                               now.hour, now.minute, now.second, drift);
                      
                      return drift > 30;  // Only sync if drift > 30 seconds
                  then:
                    - truma_inetbox.clock.set
                    - logger.log: "CP Plus clock synced (drift exceeded 30s)"

# ---------------------------------------------------------
# HARDWARE SECTION (ESP32S3_CAN_LIN_rev_B)
# ---------------------------------------------------------
uart:
  - id: lin_uart_bus
    tx_pin: 10
    rx_pin: 3
    baud_rate: 9600
    data_bits: 8
    parity: NONE
    stop_bits: 2

# ---------------------------------------------------------
# TRUMA LOGIC
# ---------------------------------------------------------

truma_inetbox:
  id: truma
  debug: false
  uart_id: lin_uart_bus
  cs_pin: 46       # LIN transceiver chip select (active HIGH)
  fault_pin: 9     # LIN transceiver fault indicator
  on_heater_message:
    then:
      - logger.log: "Message from CP Plus received."

# ---------------------------------------------------------
# Devices/entites
# ---------------------------------------------------------

number:
  - platform: truma_inetbox
    name: "Target Room Temperature"
    type: TARGET_ROOM_TEMPERATURE
  - platform: truma_inetbox
    name: "Target Water Temperature"
    type: TARGET_WATER_TEMPERATURE

binary_sensor:
  - platform: truma_inetbox
    name: "CP Plus alive"
    type: CP_PLUS_CONNECTED

  - platform: truma_inetbox
    name: "Room Heater active"
    type: HEATER_ROOM
    id: HEATER_ROOM

  - platform: truma_inetbox
    name: "Water Heater active"
    type: HEATER_WATER
    id: HEATER_WATER

  - platform: truma_inetbox
    name: "Heater has error"
    type: HEATER_HAS_ERROR

  - platform: truma_inetbox
    name: "Timer active"
    type: TIMER_ACTIVE
    id: TIMER_ACTIVE

  - platform: truma_inetbox
    name: "Timer Room Heater active"
    type: TIMER_ROOM

  - platform: truma_inetbox
    name: "Timer Water Heater active"
    type: TIMER_WATER

climate:
  - platform: truma_inetbox
    name: "Truma Room (Propane/El)"
    type: ROOM
  - platform: truma_inetbox
    name: "Truma Water"
    type: WATER
  - platform: truma_inetbox
    name: "Truma Aircon"
    type: AIRCON

sensor:
  - platform: truma_inetbox
    name: "Current Room Temperature"
    type: CURRENT_ROOM_TEMPERATURE
    filters:
      - heartbeat: 60s  # Ensure HA history gets regular updates

  - platform: truma_inetbox
    name: "Current Water Temperature"
    type: CURRENT_WATER_TEMPERATURE
    filters:
      - heartbeat: 60s

  - platform: truma_inetbox
    name: "Target Room Temperature (sensor)"
    type: TARGET_ROOM_TEMPERATURE

  - platform: truma_inetbox
    name: "Target Water Temperature (sensor)"
    type: TARGET_WATER_TEMPERATURE

  - platform: truma_inetbox
    name: "Heating mode"
    type: HEATING_MODE

  - platform: truma_inetbox
    name: "Electric power level (sensor)"
    type: ELECTRIC_POWER_LEVEL
    id: electric_power_level_sensor

  - platform: truma_inetbox
    name: "Energy mix"
    type: ENERGY_MIX
    id: energy_mix_sensor

  - platform: truma_inetbox
    name: "Operating status (raw)"
    type: OPERATING_STATUS
    id: operating_status_raw
    filters:
      - heartbeat: 60s

  - platform: truma_inetbox
    name: "Heater error code"
    type: HEATER_ERROR_CODE

  # Aircon sensors
  - platform: truma_inetbox
    name: "Aircon Target Temperature"
    type: AIRCON_TARGET_TEMPERATURE
  - platform: truma_inetbox
    name: "Aircon Current Temperature"
    type: AIRCON_CURRENT_TEMPERATURE
    filters:
      - heartbeat: 60s
  - platform: truma_inetbox
    name: "Aircon Mode"
    type: AIRCON_MODE
  - platform: truma_inetbox
    name: "Aircon Vent Mode"
    type: AIRCON_VENT_MODE

text_sensor:
  - platform: template
    name: "Heater Energy Mode"
    update_interval: 5s
    lambda: |-
      int mix = (int)id(energy_mix_sensor).state;
      int power = (int)id(electric_power_level_sensor).state;

      // Values from EnergyMix enum in TrumaEnums.h:
      // ENERGY_MIX_NONE = 0
      // ENERGY_MIX_GAS = 1 (also PROPANE)
      // ENERGY_MIX_ELECTRICITY = 2
      // ENERGY_MIX_MIX = 3

      if (std::isnan(id(energy_mix_sensor).state)) return {"N/A"};

      if (mix == 0) return {"OFF"};
      if (mix == 1) return {"PROPANE"};

      if (mix == 2) { // ELECTRICITY
         if (power == 900) return {"EL_1"};
         if (power == 1800) return {"EL_2"};
         // It might report 0W temporarily when switching or off
         return {"EL_0"};
      }

      if (mix == 3) { // MIX
         if (power == 900) return {"MIX_1"};
         if (power == 1800) return {"MIX_2"};
         return {"MIX_0"};
      }

      return {"UNKNOWN"};

  - platform: template
    name: "Operating Status"
    update_interval: 5s
    lambda: |-
      int status = (int)id(operating_status_raw).state;

      if (std::isnan(id(operating_status_raw).state)) return {"N/A"};

      switch (status) {
        case 0: return {"OFF"};
        case 1: return {"WARNING"};
        case 4: return {"START_OR_COOL_DOWN"};
        case 5: return {"ON (Stage 5)"};
        case 6: return {"ON (Stage 6)"};
        case 7: return {"ON (Stage 7)"};
        case 8: return {"ON (Stage 8)"};
        case 9: return {"ON (Stage 9)"};
        default: return {"UNKNOWN (" + std::to_string(status) + ")"};
      }

switch:
  - platform: template
    name: "Activate Room Heater"
    lambda: |-
      return id(HEATER_ROOM).state;
    turn_on_action:
      - truma_inetbox.heater.set_target_room_temperature:
          temperature: !lambda |-
            return 16;
          heating_mode: ECO # CP Plus will map this appropriately for Combi 6 D E
    turn_off_action:
      - truma_inetbox.heater.set_target_room_temperature:
          temperature: 0

  - platform: template
    name: "Activate Water Heater"
    lambda: |-
      return id(HEATER_WATER).state;
    turn_on_action:
      - truma_inetbox.heater.set_target_water_temperature:
          temperature: 40
    turn_off_action:
      - truma_inetbox.heater.set_target_water_temperature:
          temperature: 0

  - platform: template
    name: "Activate Water Heater (enum)"
    lambda: |-
      return id(HEATER_WATER).state;
    turn_on_action:
      - truma_inetbox.heater.set_target_water_temperature_enum:
          temperature: ECO
    turn_off_action:
      - truma_inetbox.heater.set_target_water_temperature_enum: "OFF"

  - platform: template
    name: "Active Timer"
    lambda: |-
      return id(TIMER_ACTIVE).state;
    turn_on_action:
      - truma_inetbox.timer.activate:
          start: 7:00
          stop: 9:30
          room_temperature: 13
          heating_mode: ECO
          water_temperature: 0
          energy_mix: GAS # Propane only
          watt: 0
    turn_off_action:
      - truma_inetbox.timer.disable

select:
  - platform: truma_inetbox
    name: "Energy Mix"
    type: HEATER_ENERGY_MIX_PROPANE

  # Aircon selects
  - platform: truma_inetbox
    name: "Aircon Operating Mode"
    type: AIRCON_MODE
  - platform: truma_inetbox
    name: "Aircon Fan Mode"
    type: AIRCON_VENT_MODE

  - platform: template
    name: "Electric Power Level"
    options:
      - "0 W"
      - "900 W"
      - "1800 W"
    lambda: |-
      if (id(electric_power_level_sensor).state == 900) {
        return std::string("900 W");
      } else if (id(electric_power_level_sensor).state == 1800) {
        return std::string("1800 W");
      }
      return std::string("0 W");
    set_action:
      - truma_inetbox.heater.set_electric_power_level:
          watt: !lambda |-
            if (x == "900 W") return 900;
            if (x == "1800 W") return 1800;
            return 0;
